# SerialCapture - Serial Man-in-the-Middle Protocol Analyzer

## Overview

SerialCapture is a C# console application that acts as a transparent man-in-the-middle proxy between two serial port endpoints, capturing and analyzing all data transmitted in both directions. It is designed to help reverse-engineer and understand serial communication protocols between software applications and hardware devices.

## Purpose

This tool sits between:
- **Software Side**: An application or software that communicates with hardware
- **Machine Side**: A physical device or machine being controlled

All data passing through the proxy is captured, logged, and analyzed in real-time without interrupting the communication flow.

## Architecture

### Communication Flow

```
Software Application <---> SerialCapture <---> Hardware Device
     (port1)                   MITM                (port2)
```

The application:
1. Opens two serial ports simultaneously
2. Listens for data on both ports using asynchronous event handlers
3. Forwards all data transparently between the ports
4. Logs all traffic with timestamps and analysis
5. Performs real-time protocol pattern analysis

### Key Components

- **Dual Serial Port Bridge**: Manages two `SerialPort` instances with bidirectional data forwarding
- **Raw Data Logger**: Captures all bytes in hexadecimal and ASCII representation
- **High-Level Protocol Analyzer**: Interprets data patterns to identify command structures
- **Configuration System**: INI-based configuration for flexible port and logging setup

## Features

### 1. Transparent Data Forwarding
- All data received on one port is immediately forwarded to the other port
- Minimal latency impact on communication
- Preserves the original protocol timing and behavior

### 2. Comprehensive Logging

#### Raw Data Log
- Timestamped entries with millisecond precision
- Hexadecimal representation of all bytes
- ASCII representation (printable characters or dots)
- Direction indicator (Software → Machine or Machine → Software)
- Color-coded console output (Cyan for Software, Yellow for Machine)

**Example Raw Log Entry:**
```
[2025-10-17 13:45:12.456] Software → Machine: 4D 01 42 (M.B)
[2025-10-17 13:45:12.489] Machine → Software: 4D 01 42 (M.B)
```

#### High-Level Protocol Analysis Log
Interprets communication patterns to classify data types:

- **Software Command**: Commands from software that are echoed by the machine
- **Software Data**: Data sent by software that doesn't get echoed
- **Machine Data**: Responses or data generated by the machine
- **Error Data**: Commands that were not properly acknowledged

The analyzer accumulates consecutive bytes of the same type and logs them as coherent messages.

**Example High-Level Log Entry:**
```
[2025-10-17 13:45:12.456] Software Command: M
[2025-10-17 13:45:12.489] Machine Data:     Preview Ready
```

### 3. Protocol Pattern Detection

The application implements a state machine to detect command-response patterns:

- **Buffer State**: Tracks potential commands from software
- **Echo Detection**: Identifies when the machine echoes commands
- **Data Accumulation**: Groups consecutive bytes of the same classification
- **Error Detection**: Flags unexpected machine responses

This helps identify:
- Command-echo protocols (where devices acknowledge commands)
- Request-response patterns
- Unsolicited machine data
- Protocol errors or mismatches

### 4. Configurable Settings

Controlled via `config.ini`:
- **Software**: Serial port name for software side (e.g., COM3)
- **Machine**: Serial port name for machine side (e.g., COM4)
- **file**: Path to raw data log file
- **hfile**: Path to high-level protocol analysis log file
- **loghex**: Optional flag to include hex data in high-level log (true/false)

### 5. Real-Time Console Display

- Color-coded output for easy visual differentiation
- Timestamps for all events
- Live view of all captured data
- Error reporting and diagnostics

## Technical Specifications

### Serial Port Configuration
- **Baud Rate**: 57600 (hard-coded)
- **Data Bits**: 8
- **Parity**: None
- **Stop Bits**: 1
- **Handshake**: None
- **Timeouts**: 500ms read/write

### Threading Model
- Asynchronous event-driven architecture using `SerialPort.DataReceived` events
- Thread-safe logging with lock synchronization
- Efficient forwarding with minimal processing overhead

### Error Handling
- Graceful shutdown on CTRL+C
- Port access error detection (permissions, conflicts)
- Exception logging for debugging
- Automatic cleanup of resources

## Use Cases

1. **Protocol Reverse Engineering**: Capture communication to understand proprietary protocols
2. **Debugging**: Diagnose communication issues between software and hardware
3. **Protocol Documentation**: Generate logs for creating protocol specifications
4. **Testing**: Verify correct implementation of serial protocols
5. **Education**: Learn how serial communication protocols work

## Output Files

### Raw Data Log (`output-*.txt`)
Complete byte-level capture with:
- Direction of each transmission
- Exact timing information
- Hexadecimal and ASCII representation
- Session metadata (start/end times, configuration)

### High-Level Protocol Log (`houtput-*.txt`)
Interpreted protocol analysis with:
- Classified message types
- Accumulated data sequences
- Pattern recognition results
- Optional hexadecimal data (if `loghex=true`)

## Limitations

- Fixed baud rate (57600) - requires code modification for other rates
- Assumes 8N1 configuration (8 data bits, no parity, 1 stop bit)
- No built-in protocol definitions - requires manual interpretation
- Real-time processing only - no post-capture analysis features

## Dependencies

- **.NET 8.0**: Modern .NET runtime
- **System.IO.Ports**: Serial port communication library
- No external packages or frameworks required

## Best Practices for Use

1. **Connect Properly**: Ensure correct TX/RX and ground connections
2. **Test Configuration**: Verify port names match your system's COM ports
3. **Descriptive Log Names**: Use meaningful filenames to organize captures
4. **Monitor Console**: Watch real-time output for immediate feedback
5. **Analyze Patterns**: Look for repeating sequences in high-level logs
6. **Document Findings**: Annotate discovered protocol patterns

## Safety Notes

- The application opens both ports exclusively - ensure no other software is using them
- Data is forwarded with minimal validation - ensure connections are correct
- Log files grow with captured data - monitor disk space for long sessions
- CTRL+C gracefully shuts down - always use it to ensure proper cleanup

## Future Enhancement Possibilities

- Configurable baud rates and serial parameters
- Protocol definition files for automatic interpretation
- Statistics and analysis dashboards
- Filtering and triggering capabilities
- Packet framing detection
- Checksum validation
- Real-time graphical visualization
